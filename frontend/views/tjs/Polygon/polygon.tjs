function(errorLayer, tempLayer, polygonStack, polygonSymbol, layerStack, parameters){

  const radiusValidationClass = {{reglue:"Polygon/Validation/radiusValidation"}};
  const topologyValidationClass = {{reglue:"Polygon/Validation/topologyValidation"}};
  let topologyValidation = topologyValidationClass();

  var polygonEditGraphic;

  function addRailwayPolygon(event) {
    // console.log(event.geometry);
    // console.log(sketchViewModel.graphic.symbol);
    // console.log(sketchViewModel);
    if (event.tool !== "polyline") {
      return;
    }
    getImpossibleSegment(event.geometry);
    const ring = [getPolygonPointsFromPolylinePoints(event.geometry.paths[0])];
    const polygon = new Polygon({
      hasZ: true,
      hasM: true,
      rings: ring,
      spatialReference: {wkid: 102100}
    });
    const graphic = new Graphic({
      geometry: polygon,
      symbol: polygonSymbol
    });
    tempLayer.add(graphic);
    polygonStack[polygonEditGraphic.graphicId] = graphic;
    var priceCheckerClass = {{reglue:"Connector/priceChecker"}};
    var priceChecker = priceCheckerClass(polygonStack, layerStack);



  }

  function updateRailwayPolygon(event) {
    event.tool = "polyline";
    getImpossibleSegment(event.geometry);
    // console.log(oldPolygon);
    addRailwayPolygon(event);
  }

  function removeRailwayPolygon(event) {
    getImpossibleSegment(event.geometry);
    let oldPolygon = polygonStack[polygonEditGraphic.graphicId];
    // console.log(oldPolygon);
    const index = polygonStack.indexOf(polygonEditGraphic);
    if(index >= 0){
      polygonStack.splice(index,1);
    }
    tempLayer.remove(oldPolygon);
  }

  function getPolygonPointsFromPolylinePoints(points) {
    if (points.length < 2) {
      return null;
    }
    let rings = [];
    for (let i = 0; i < 2 * points.length + 1; i++) {
      rings.push([]);
    }
    for (let i = 0; i < points.length; i++) {
      let polygonPoints;
      if (i === 0) {
        polygonPoints = getEdgePolygonPoints(points[i], points[i + 1], points[i], parameters.roadWidth);
        rings[2 * points.length] = polygonPoints.first;
        rings[1] = polygonPoints.second;
        rings[0] = polygonPoints.first;
        continue;
      } else if (i === points.length - 1) {
        polygonPoints = getEdgePolygonPoints(points[i - 1], points[i], points[i], parameters.roadWidth);
      } else {
        polygonPoints = getCenterPolygonPoints(points[i - 1], points[i], points[i + 1], parameters.roadWidth);
      }
      rings[1 + i] = polygonPoints.second;
      rings[2 * points.length - i] = polygonPoints.first;
    }
    return rings;
  }

  function getEdgePolygonPoints(firstPoint, secondPoint, edgePoint, distance) {
    let scaledVector = scaleVectorToDistance([secondPoint[0] - firstPoint[0], secondPoint[1] - firstPoint[1]], distance);
    let points = {first: [], second: []};

    points.first = [edgePoint[0] - scaledVector[1], edgePoint[1] + scaledVector[0]];
    points.second = [edgePoint[0] + scaledVector[1], edgePoint[1] - scaledVector[0]];

    return points;
  }

  function getCenterPolygonPoints(A, B, C, distance) {
    let vectorBC = scaleVectorToDistance([C[0] - B[0], C[1] - B[1]], distance);
    let vectorBA = scaleVectorToDistance([A[0] - B[0], A[1] - B[1]], distance);
    let vector = [vectorBA[0] + vectorBC[0], vectorBA[1] + vectorBC[1]];
    let points = {first: [], second: []};
    let sinusSign = (vectorBC[0] * vectorBA[1] - vectorBC[1] * vectorBA[0]);
    if (sinusSign < 0) {
      vector[0] = -vector[0];
      vector[1] = -vector[1];
    }
    if (vector[0] === 0 && vector[1] === 0) {
      points = getEdgePolygonPoints(B, C, B, distance);
    } else {
      vector = scaleVectorToDistance(vector, distance);
      points.first = [B[0] + vector[0], B[1] + vector[1]];
      points.second = [B[0] - vector[0], B[1] - vector[1]];
    }
    return points;
  }

  function scaleVectorToDistance(vector, distance) {
    let vectorLength = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
    return [vector[0] * distance / vectorLength, vector[1] * distance / vectorLength];
  }

  function getImpossibleSegment(polyline) {
    errorLayer.removeAll();
    if (polyline.type !== "polyline") {
      return;
    }

    //radius validation
    let radiusValidation = radiusValidationClass(parameters);
    let segment = radiusValidation.getImpossibleRadiusSegments(polyline);
    if (segment != null) {
      let graphic = new Graphic({
        geometry: segment,
        symbol: symbols.polylineError
      });
      errorLayer.add(graphic);
    }
    topologyValidation.getImpossibleTopologySegment(polyline);

    //topology validation
  }


  return {
    addPolygon: function(event){
      return addRailwayPolygon(event);
    },
    updatePolygon: function(event){
      return updateRailwayPolygon(event);
    },
    setEditGraphic: function(editGraphic){
      polygonEditGraphic = editGraphic;
    },
    removePolygon: function(editGraphic){
      console.log(polygonStack);
      return removeRailwayPolygon(editGraphic)
    }
  };
}
