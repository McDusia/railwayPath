{
  testfunction: function(){
    console.log(railwaySize);
  },

  addRailwayPolygon: function(event) {
    // console.log(event.geometry);
    // console.log(sketchViewModel.graphic.symbol);
    // console.log(sketchViewModel);
    if (event.geometry.type !== "polyline") {
      return;
    }
    getImpossibleSegment(event.geometry);
    const ring = [this.getPolygonPointsFromPolylinePoints(event.geometry.paths[0])];
    const polygon = new Polygon({
      hasZ: true,
      hasM: true,
      rings: ring,
      spatialReference: {wkid: 102100}
    });
    const graphic = new Graphic({
      geometry: polygon,
      symbol: polygonSymbol
    });
    tempLayer.add(graphic);
    polygonStack[polygonEditGraphic.graphicId] = graphic;

  },

  updateRailwayPolygon: function(event) {
    if (event.geometry.type !== "polyline") {
      return;
    }
    getImpossibleSegment(event.geometry);
    let oldPolygon = polygonStack[polygonEditGraphic.graphicId];
    // console.log(oldPolygon);
    polygonStack[polygonEditGraphic.graphicId] = null;
    tempLayer.remove(oldPolygon);
    this.addRailwayPolygon(event);
  },

  getPolygonPointsFromPolylinePoints: function(points) {
    if (points.length < 2) {
      return null;
    }
    let rings = [];
    for (let i = 0; i < 2 * points.length + 1; i++) {
      rings.push([]);
    }
    for (let i = 0; i < points.length; i++) {
      let polygonPoints;
      if (i === 0) {
        polygonPoints = this.getEdgePolygonPoints(points[i], points[i + 1], points[i], railwaySize);
        rings[2 * points.length] = polygonPoints.first;
        rings[1] = polygonPoints.second;
        rings[0] = polygonPoints.first;
        continue;
      } else if (i === points.length - 1) {
        polygonPoints = this.getEdgePolygonPoints(points[i - 1], points[i], points[i], railwaySize);
      } else {
        polygonPoints = this.getCenterPolygonPoints(points[i - 1], points[i], points[i + 1], railwaySize);
      }
      rings[1 + i] = polygonPoints.second;
      rings[2 * points.length - i] = polygonPoints.first;
    }
    return rings;
  },

  getEdgePolygonPoints: function(firstPoint, secondPoint, edgePoint, distance) {
    let scaledVector = this.scaleVectorToDistance([secondPoint[0] - firstPoint[0], secondPoint[1] - firstPoint[1]], distance);
    let points = {first: [], second: []};

    points.first = [edgePoint[0] - scaledVector[1], edgePoint[1] + scaledVector[0]];
    points.second = [edgePoint[0] + scaledVector[1], edgePoint[1] - scaledVector[0]];

    return points;
  },

  getCenterPolygonPoints: function(A, B, C, distance) {
    let vectorBC = this.scaleVectorToDistance([C[0] - B[0], C[1] - B[1]], distance);
    let vectorBA = this.scaleVectorToDistance([A[0] - B[0], A[1] - B[1]], distance);
    let vector = [vectorBA[0] + vectorBC[0], vectorBA[1] + vectorBC[1]];
    let points = {first: [], second: []};
    let sinusSign = (vectorBC[0] * vectorBA[1] - vectorBC[1] * vectorBA[0]);
    if (sinusSign < 0) {
      vector[0] = -vector[0];
      vector[1] = -vector[1];
    }
    if (vector[0] === 0 && vector[1] === 0) {
      points = this.getEdgePolygonPoints(B, C, B, distance);
    } else {
      vector = this.scaleVectorToDistance(vector, distance);
      points.first = [B[0] + vector[0], B[1] + vector[1]];
      points.second = [B[0] - vector[0], B[1] - vector[1]];
    }
    return points;
  },

  scaleVectorToDistance: function(vector, distance) {
    let vectorLength = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
    return [vector[0] * distance / vectorLength, vector[1] * distance / vectorLength];
  }
};
